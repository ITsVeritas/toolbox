#Requires -RunAsAdministrator
<#
.SYNOPSIS
THIS SCRIPT ISN'T DONE! DO NOT USE!
    Script applies the steps outline in https://support.microsoft.com/en-us/topic/how-to-manage-the-windows-boot-manager-revocations-for-secure-boot-changes-associated-with-cve-2023-24932-41a975df-beb2-40c1-99a3-b3ff139f832d#bkmk_install
.EXAMPLE
    Apply-CVE-2023-24932.ps1
.NOTES
    Version: 1.0
    Author: Martin Himken
    Original script name: Apply-CVE-2023-24932.ps1
    Initial 19.02.2025
    Last Update: 02.03.2025
#>
param(
    [System.IO.DirectoryInfo]$WorkingDirectory = "C:\BLR\",
    [System.IO.DirectoryInfo]$LogDirectory = "C:\BLR\",
    $LockscreenImagePath = "lockscreen.jpg",
    $RegistryPath = "HKLM:\SOFTWARE\Apply-CVE-2023-24932"
)
function Initialize-Script {
    <#
    .SYNOPSIS
    Will initialize most of the required variables throughout this script.
    #>
    $Script:DateTime = Get-Date -Format yyyyMMdd_HHmmss
    if (-not($Script:CurrentLocation)) {
        $Script:CurrentLocation = Get-Location
    }
    if (-not(Test-Path $WorkingDirectory )) { New-Item $WorkingDirectory -ItemType Directory -Force | Out-Null } 
    if ((Get-Location).path -ne $WorkingDirectory) {
        Set-Location $WorkingDirectory
    }
    Get-ScriptPath
    if (-not($Script:LogFile)) {
        $LogPrefix = '23-24932' #CVE2023-24932 Fix
        $Script:LogFile = Join-Path -Path $LogDirectory -ChildPath ('{0}_{1}.log' -f $LogPrefix, $Script:DateTime)
        if (-not(Test-Path $LogDirectory)) { New-Item $LogDirectory -ItemType Directory -Force | Out-Null }
    }
    if ($PSVersionTable.psversion.major -lt 7) {
        Write-Log -Message 'Please follow the manual - PowerShell 7 is currently required to run this script.' -Component 'InitializeScript' -Type 3
        Exit 1
    }
    $FullLockscreenImagePath = Join-Path -Path $WorkingDirectory -ChildPath $LockscreenImagePath
    if (-not(Test-Path $RegistryPath)) {
        New-Item -Path $RegistryPath -ItemType File -Force
        $Script:WasRunBefore = Get-ItemProperty -Path $RegistryPath -Name 'InitialRunDate' -ErrorAction SilentlyContinue
        if (-not($Script:WasRunBefore)) {
            New-ItemProperty -Path $RegistryPath -Name 'InitialRunDate' -Value $Script:DateTime
        } else {
            New-ItemProperty -Path $RegistryPath -Name 'LastRunDate' -Value $Script:DateTime
        }
    }
    #ToDO!
    #$WindowsMajorCorrected =  [System.Environment]::OSVersion.Version | ForEach-Object {}
}
function Write-Log {
    <#
    .DESCRIPTION
        This is a modified version of the script by Ryan Ephgrave.
        .LINK
        https://www.ephingadmin.com/powershell-cmtrace-log-function/
    #>
    Param (
        [Parameter(Mandatory = $false)]
        $Message,
        $Component,
        # Type: 1 = Normal, 2 = Warning (yellow), 3 = Error (red)
        [ValidateSet('1', '2', '3')][int]$Type
    )
    if (-not($NoLog)) {
        $Time = Get-Date -Format 'HH:mm:ss.ffffff'
        $Date = Get-Date -Format 'MM-dd-yyyy'
        if (-not($Component)) { $Component = 'Runner' }
        if (-not($ToConsole)) {
            $LogMessage = "<![LOG[$Message" + "]LOG]!><time=`"$Time`" date=`"$Date`" component=`"$Component`" context=`"`" type=`"$Type`" thread=`"`" file=`"`">"
            $LogMessage | Out-File -Append -Encoding UTF8 -FilePath $LogFile
        } elseif ($ToConsole) {
            switch ($type) {
                1 { Write-Host "T:$Type C:$Component M:$Message" }
                2 { Write-Host "T:$Type C:$Component M:$Message" -BackgroundColor Yellow -ForegroundColor Black }
                3 { Write-Host "T:$Type C:$Component M:$Message" -BackgroundColor Red -ForegroundColor White }
                default { Write-Host "T:$Type C:$Component M:$Message" }
            }
        }
    }
}

function Get-FixStatus {
    $Script:CurrentDBStatusRegistry = (Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\SecureBoot\Servicing" -Name 'WindowsUEFICA2023Capable').WindowsUEFICA2023Capable
    $Script:SecureBootDBStatus = [System.Text.Encoding]::ASCII.GetString((Get-SecureBootUEFI db).bytes) -match 'Windows UEFI CA 2023'
    $Script:SecureBootDBXStatus = [System.Text.Encoding]::ASCII.GetString((Get-SecureBootUEFI dbx).bytes) -match 'Microsoft Windows Production PCA 2011' 
    $Script:CurrentAvailableUpdatesValue = (Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecureBoot -Name 'AvailableUpdates').AvailableUpdates
}
function Get-FixPhase {
    Get-FixStatus
    switch ($Script:CurrentDBStatusRegistry) {
        "0" { $WindowsUEFICA2023Capable = "NotInDB" }
        "1" { $WindowsUEFICA2023Capable = "Prepared" }
        "2" { $WindowsUEFICA2023Capable = "PreparedAndActive" }
        default { $WindowsUEFICA2023Capable = "NotInDB" }
    }
    switch ($Script:CurrentAvailableUpdatesValue) {
        "0" { $Script:CurrentPhase = "Eval" }
        "320" { $Script:CurrentPhase = 1 }
        "256" { $Script:CurrentPhase = 2 }
        "640" { $Script:CurrentPhase = 3 }
        default { $Script:CurrentPhase = $false }
    }
    if (-not($Script:CurrentPhase)) {
        Write-Log -Message 'AvailableUpdates key is missing the required July 2024 patch probably was not applied' -Component 'GetFixPhase' -Type 3
        Exit 1
    }
    if ($Script:CurrentPhase -eq "Eval" -and -not($Script:SecureBootDBStatus) -and -not($Script:SecureBootDBXStatus)) {        
        Write-Log 'Machine is not patched yet, starting phase 1' -Component 'GetFixPhase'
        Start-PhaseOne
    }
    if ($Script:CurrentPhase -eq "2" -and $Script:SecureBootDBStatus -and $WindowsUEFICA2023Capable -eq 'Prepared') {     
        Write-Log 'Phase 1 completed, next reboot will make it phase two - rebooting' -Component 'GetFixPhase'
        Start-PhaseTwo
    }
    if ($Script:CurrentPhase -eq "Eval" -and $WindowsUEFICA2023Capable -eq "Prepared") {        
        #Might not be required!
    }
    if ($Script:CurrentPhase -eq "Eval" -and $WindowsUEFICA2023Capable -eq "PreparedAndActive" -and -not($Script:SecureBootDBXStatus)) {        
        Start-PhaseThree
    }
    if ($Script:CurrentPhase -eq "Eval" -and $WindowsUEFICA2023Capable -eq "PreparedAndActive" -and $Script:SecureBootDBXStatus){
        Start-PhaseFinish
    }
}

function Start-PhaseOne {
    New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecureBoot -Name 'AvailableUpdates' -PropertyType DWORD -Value 320 -Force | Out-Null
    Restart-ComputerControl -EventIDToWaitfor 1800
}
function Start-PhaseTwo {
    Restart-ComputerControl -EventIDToWaitfor 1799
}
function Start-PhaseThree {
    New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecureBoot -Name 'AvailableUpdates' -PropertyType DWORD -Value 640 -Force | Out-Null
    Restart-ComputerControl -EventIDToWaitfor 1042
}

function Restart-ComputerControl {
    param(
        [int]$EventIDToWaitfor
    )
    if(-not($EventIDToWaitfor)){
    Write-Log -Message "No event ID provided - Computer will restart"-Component 'Restart'
        #RESTART THE COMPUTER - LOCK SCREEN
    }
    else{
        #Find EventID given and THEN reboot
        while(-not($Script:EventFound)){
            $Script:EventFound = Get-WinEvent -LogName System -FilterXPath "*[System[Provider[@Name='Microsoft-Windows-TPM-WMI']][EventID=$EventIDToWaitfor]]"
            Start-Sleep -Seconds 5
        }
    }
    Exit 1610
    #Scheduled task that checks for EventIDToWaitFor and then auto-reboots
    #Needs a way to block the users from sign-in - unlock if it takes longer than 5 minutes
    #Add custom Lockscreen in the meantime
}

Start-CVEErrorHandling{
    $Errors = Get-WinEvent -LogName System -FilterXPath "*[System[Provider[@Name='Microsoft-Windows-TPM-WMI'] and (EventID=1795 or EventID=1796 or EventID=1797 or EventID=1798)]]" -ErrorAction SilentlyContinue
    if(-not($Errors)){
        Write-Log -Message 'No errors found after reboot - continue' -Component 'CVEErrorHandling'
        return true
    }
    else{
        Write-Log -Message  "Error $(($Errors | Select-Object -First 1).id) found after reboot! Please troubleshoot this manually!" -Component 'CVEErrorHandling' -Type 3
        return $false
    }
}

#Start coding!
#ADJUST TO HOWEVER MANY PHASES WE NEED!
Get-FixPhase
if ($FIXMEIFDONE) {
    Write-Log -Message 'The bootloader is now signed with the current Windows UEFI CA 2023' -Component 'BlackLotusFixMain'
    Set-Location $Script:CurrentLocation
    #Exit 0
}
Write-Log -Message 'If you reached this point, it means something went wrong.' -Component 'BlackLotusFixMain'
#Exit 1